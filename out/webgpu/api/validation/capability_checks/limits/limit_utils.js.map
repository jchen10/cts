{"version":3,"file":"limit_utils.js","names":["Fixture","kUnitCaseParamsBuilder","makeTestGroup","keysOf","getGPU","assert","kLimitInfo","TestValue","atLimit","overLimit","kTestValueKeys","getTestValue","limit","testValue","LimitValueTest","atDefault","underDefault","atMaximum","overMaximum","kLimitValueTestKeys","getLimitValue","defaultLimit","maximumLimit","limitValueTest","kLimitBaseParams","combine","beginSubcases","LimitTestsImpl","_device","undefined","device","requestDeviceWithLimits","adapter","requiredLimits","shouldReject","requestDevice","_getDeviceWithRequestedLimit","gpu","requestAdapter","default","limits","Number","isNaN","requestedLimit","actualLimit","expect","testDeviceWithRequestedLimits","limitTest","testValueName","fn","deviceAndLimits","shouldError","pushErrorScope","validationError","popErrorScope","outOfMemoryError","internalError","message","destroy","expectGPUError","filter","msg","returnValue","Promise","error","expectValidationError","expectNoValidationError","testForValidationErrorWithPossibleOutOfMemoryError","result","makeLimitTestFixture","LimitTests","makeLimitTestGroup","description","g"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/limit_utils.ts"],"sourcesContent":["import { Fixture } from '../../../../../common/framework/fixture.js';\nimport { kUnitCaseParamsBuilder } from '../../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../common/util/data_tables.js';\nimport { getGPU } from '../../../../../common/util/navigator_gpu.js';\nimport { assert } from '../../../../../common/util/util.js';\nimport { kLimitInfo } from '../../../../capability_info.js';\n\ntype GPUSupportedLimit = keyof GPUSupportedLimits;\n\nexport const TestValue = {\n  atLimit: true,\n  overLimit: true,\n};\n\nexport const kTestValueKeys = keysOf(TestValue);\n\nexport function getTestValue(limit: number, testValue: keyof typeof TestValue) {\n  switch (testValue) {\n    case 'atLimit':\n      return limit;\n    case 'overLimit':\n      return limit + 1;\n  }\n}\n\nexport const LimitValueTest = {\n  atDefault: true,\n  underDefault: true,\n  atMaximum: true,\n  overMaximum: true,\n};\nexport const kLimitValueTestKeys = keysOf(LimitValueTest);\n\nfunction getLimitValue(\n  defaultLimit: number,\n  maximumLimit: number,\n  limitValueTest: keyof typeof LimitValueTest\n) {\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - 1;\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + 1;\n  }\n}\n\nexport type DeviceAndLimits = {\n  device: GPUDevice;\n  defaultLimit: number;\n  maximumLimit: number;\n  requestedLimit: number;\n  actualLimit: number;\n};\n\nexport type LimitTestInputs = DeviceAndLimits & {\n  testValueName: keyof typeof TestValue;\n  testValue: number;\n  shouldError: boolean;\n};\n\n/**\n * Adds the default parameters to a limit test\n */\nexport const kLimitBaseParams = kUnitCaseParamsBuilder\n  .combine('limitTest', kLimitValueTestKeys)\n  .beginSubcases()\n  .combine('testValueName', kTestValueKeys);\n\nexport class LimitTestsImpl extends Fixture {\n  _device: GPUDevice | undefined = undefined;\n  limit: GPUSupportedLimit = '' as GPUSupportedLimit;\n\n  get device(): GPUDevice {\n    assert(\n      this._device !== undefined,\n      'device is only valid in testDeviceWithRequestedLimits callback'\n    );\n    return this._device;\n  }\n\n  async requestDeviceWithLimits(\n    limitValueTest: keyof typeof LimitValueTest,\n    adapter: GPUAdapter,\n    requiredLimits: Record<string, number>\n  ) {\n    switch (limitValueTest) {\n      case 'overMaximum':\n        this.shouldReject('OperationError', adapter.requestDevice({ requiredLimits }));\n        return undefined;\n      default:\n        return await adapter.requestDevice({ requiredLimits });\n    }\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithRequestedLimit(\n    limitValueTest: keyof typeof LimitValueTest\n  ): Promise<DeviceAndLimits | undefined> {\n    const limit = this.limit;\n    const gpu = getGPU();\n    const adapter = await gpu.requestAdapter();\n    assert(!!adapter);\n\n    const defaultLimit = (kLimitInfo as Record<string, { default: number }>)[limit].default;\n    const maximumLimit = adapter.limits[limit] as number;\n    assert(!Number.isNaN(defaultLimit));\n    assert(!Number.isNaN(maximumLimit));\n\n    const requestedLimit = getLimitValue(defaultLimit, maximumLimit, limitValueTest);\n\n    const requiredLimits: Record<string, number> = {};\n    requiredLimits[limit] = requestedLimit;\n\n    const device = await this.requestDeviceWithLimits(limitValueTest, adapter, requiredLimits);\n    const actualLimit = (device ? device.limits[limit] : 0) as number;\n\n    switch (limitValueTest) {\n      case 'atDefault':\n        this.expect(!!device);\n        this.expect(actualLimit === defaultLimit);\n        break;\n      case 'underDefault':\n        this.expect(!!device);\n        this.expect(actualLimit === defaultLimit);\n        break;\n      case 'atMaximum':\n        this.expect(!!device);\n        this.expect(actualLimit === maximumLimit);\n        break;\n      case 'overMaximum':\n        this.expect(!device);\n        break;\n    }\n\n    return device ? { device, defaultLimit, maximumLimit, requestedLimit, actualLimit } : undefined;\n  }\n\n  /**\n   * Creates a device with the requested limits.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithRequestedLimits(\n    limitTest: keyof typeof LimitValueTest,\n    testValueName: keyof typeof TestValue,\n    fn: (inputs: LimitTestInputs) => void | Promise<void>\n  ) {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithRequestedLimit(limitTest);\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    const { device, actualLimit } = deviceAndLimits;\n    this._device = device;\n    const testValue = getTestValue(actualLimit, testValueName);\n    const shouldError = testValueName === 'overLimit';\n\n    device.pushErrorScope('internal');\n    device.pushErrorScope('out-of-memory');\n    device.pushErrorScope('validation');\n\n    await fn({ ...deviceAndLimits, testValueName, testValue, shouldError });\n\n    const validationError = await device.popErrorScope();\n    const outOfMemoryError = await device.popErrorScope();\n    const internalError = await device.popErrorScope();\n\n    this.expect(!validationError, validationError?.message || '');\n    this.expect(!outOfMemoryError, outOfMemoryError?.message || '');\n    this.expect(!internalError, internalError?.message || '');\n\n    device.destroy();\n    this._device = undefined;\n  }\n\n  /**\n   * Calls a function that expects a GPU error if shouldError is true\n   */\n  // MAINTENANCE_TODO: Remove this duplicated code with GPUTest if possible\n  async expectGPUError<R>(\n    filter: GPUErrorFilter,\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    device.pushErrorScope(filter);\n    const returnValue = fn();\n    if (returnValue instanceof Promise) {\n      await returnValue;\n    }\n\n    const error = await device.popErrorScope();\n    this.expect(\n      !!error === shouldError,\n      `${error?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  /**\n   * Calls a function that expects a validation error if shouldError is true\n   */\n  async expectValidationError<R>(fn: () => R, shouldError: boolean = true, msg = ''): Promise<R> {\n    return this.expectGPUError('validation', fn, shouldError, msg);\n  }\n\n  /**\n   * Calls a function that expects to not generate a validation error\n   */\n  async expectNoValidationError<R>(fn: () => R, msg = ''): Promise<R> {\n    return this.expectGPUError('validation', fn, false, msg);\n  }\n\n  /**\n   * Calls a function that might expect a validation error.\n   * if shouldError is true then expect a validation error,\n   * if shouldError is false then ignore out-of-memory errors.\n   */\n  async testForValidationErrorWithPossibleOutOfMemoryError<R>(\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    if (!shouldError) {\n      device.pushErrorScope('out-of-memory');\n      const result = fn();\n      await device.popErrorScope();\n      return result;\n    }\n\n    // Validation should fail before out-of-memory so there is no need to check\n    // for out-of-memory here.\n    device.pushErrorScope('validation');\n    const returnValue = fn();\n    const validationError = await device.popErrorScope();\n\n    this.expect(\n      !!validationError,\n      `${validationError?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n}\n\n/**\n * Makes a new LimitTest class so that the tests have access to `limit`\n */\nfunction makeLimitTestFixture(limit: GPUSupportedLimit): typeof LimitTestsImpl {\n  class LimitTests extends LimitTestsImpl {\n    limit = limit;\n  }\n\n  return LimitTests;\n}\n\n/**\n * This is to avoid repeating yourself (D.R.Y.) as I ran into that issue multiple times\n * writing these tests where I'd copy a test, need to rename a limit in 3-4 places,\n * forget one place, and then spend 20-30 minutes wondering why the test was failing.\n */\nexport function makeLimitTestGroup(limit: GPUSupportedLimit) {\n  const description = `API Validation Tests for ${limit}.`;\n  const g = makeTestGroup(makeLimitTestFixture(limit));\n  return { g, description, limit };\n}\n"],"mappings":"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"}