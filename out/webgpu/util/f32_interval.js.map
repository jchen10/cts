{"version":3,"sources":["../../../src/webgpu/util/f32_interval.ts"],"names":["assert","kValue","correctlyRoundedF32","flushSubnormalNumber","isF32Finite","oneULP","F32Interval","constructor","begin","end","Number","isNaN","NEGATIVE_INFINITY","f32","negative","min","POSITIVE_INFINITY","positive","max","contains","n","i","toInterval","isPoint","span","intervals","length","forEach","Math","toString","infinite","_infinite","undefined","roundAndFlushPointToInterval","op","values","inputs","Set","map","results","impl","roundAndFlushBinaryToInterval","x","y","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushTernaryToInterval","z","z_values","z_inputs","inner_z","runPointOp","extrema","runBinaryOp","runTernaryOp","correctlyRoundedInterval","impl_n","absoluteErrorInterval","error_range","ulpInterval","numULP","abs","ulp","absInterval","atanInterval","atan","ceilInterval","ceil","cosInterval","pi","whole","cos"],"mappings":"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","sourcesContent":["import { assert } from '../../common/util/util.js';\n\nimport { kValue } from './constants.js';\nimport { correctlyRoundedF32, flushSubnormalNumber, isF32Finite, oneULP } from './math.js';\n\n/** Represents a closed interval in the f32 range */\nexport class F32Interval {\n  public readonly begin: number;\n  public readonly end: number;\n  private static _infinite: F32Interval;\n\n  /** Constructor\n   *\n   * Bounds that are out of range for F32 are converted to appropriate edge or\n   * infinity values, so that all values above/below the f32 range are lumped\n   * together.\n   *\n   * @param begin number indicating the lower bound of the interval\n   * @param end number indicating the upper bound of the interval\n   */\n  public constructor(begin: number, end: number) {\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `begin (${begin}) must be equal or before end (${end})`);\n\n    if (begin === Number.NEGATIVE_INFINITY || begin < kValue.f32.negative.min) {\n      this.begin = Number.NEGATIVE_INFINITY;\n    } else if (begin === Number.POSITIVE_INFINITY || begin > kValue.f32.positive.max) {\n      this.begin = kValue.f32.positive.max;\n    } else {\n      this.begin = begin;\n    }\n\n    if (end === Number.POSITIVE_INFINITY || end > kValue.f32.positive.max) {\n      this.end = Number.POSITIVE_INFINITY;\n    } else if (end === Number.NEGATIVE_INFINITY || end < kValue.f32.negative.min) {\n      this.end = kValue.f32.negative.min;\n    } else {\n      this.end = end;\n    }\n  }\n\n  /** @returns if a point or interval is completely contained by this interval\n   *\n   * Due to values that are above/below the f32 range being indistinguishable\n   * from other values out of range in the same way, there some unintuitive\n   * behaviours here, for example:\n   *   [0, greater than max f32].contains(+∞) will return true.\n   */\n  public contains(n: number | F32Interval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the infinite interval indicates that the accuracy is not defined\n      // for this test, so the test is just checking that this input doesn't\n      // cause the implementation to misbehave, so NaN is acceptable.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n    const i = toInterval(n);\n    return this.begin <= i.begin && this.end >= i.end;\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns an interval with the tightest bounds that includes all provided intervals */\n  static span(...intervals: F32Interval[]): F32Interval {\n    assert(intervals.length > 0, `span of an empty list of F32Intervals is not allowed`);\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return new F32Interval(begin, end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `[${this.begin}, ${this.end}]`;\n  }\n\n  /** @returns a singleton for the infinite interval\n   * This interval is used in situations where accuracy is not defined, so any\n   * result is valid.\n   */\n  public static infinite(): F32Interval {\n    if (this._infinite === undefined) {\n      this._infinite = new F32Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n    return this._infinite;\n  }\n}\n\n/** @returns an interval containing the point or the original interval */\nfunction toInterval(n: number | F32Interval): F32Interval {\n  if (n instanceof F32Interval) {\n    return n;\n  }\n  return new F32Interval(n, n);\n}\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToInterval {\n  (x: number): F32Interval;\n}\n\n/** Operation used to implement a PointToInterval */\ninterface PointToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: (x: number) => F32Interval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * If not defined the ends of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | F32Interval, not x: number\n   */\n  extrema?: (x: F32Interval) => F32Interval;\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface BinaryToInterval {\n  (x: number, y: number): F32Interval;\n}\n\n/** Operation used to implement a BinaryToInterval */\ninterface BinaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: (x: number, y: number) => F32Interval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * If not defined the ends of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: F32Interval, y: F32Interval) => [F32Interval, F32Interval];\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface TernaryToInterval {\n  (x: number, y: number, z: number): F32Interval;\n}\n\n/** Operation used to implement a TernaryToInterval */\ninterface TernaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: (x: number, y: number, z: number) => F32Interval;\n  // All current ternary operations that are used in inheritance (clamp*) are\n  // monotonic, so extrema calculation isn't needed. Re-using the Op interface\n  // pattern for symmetry with the other operations\n}\n\n/** Converts a point to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param n value to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushPointToInterval(n: number, op: PointToIntervalOp) {\n  assert(!Number.isNaN(n), `flush not defined for NaN`);\n  const values = correctlyRoundedF32(n);\n  const inputs = new Set<number>([...values, ...values.map(flushSubnormalNumber)]);\n  const results = new Set<F32Interval>([...inputs].map(op.impl));\n  return F32Interval.span(...results);\n}\n\n/** Converts a pair to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushBinaryToInterval(x: number, y: number, op: BinaryToIntervalOp): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const x_inputs = new Set<number>([...x_values, ...x_values.map(flushSubnormalNumber)]);\n  const y_inputs = new Set<number>([...y_values, ...y_values.map(flushSubnormalNumber)]);\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a triplet to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x, y & z are run.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param z third param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushTernaryToInterval(\n  x: number,\n  y: number,\n  z: number,\n  op: TernaryToIntervalOp\n): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  assert(!Number.isNaN(z), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const z_values = correctlyRoundedF32(z);\n  const x_inputs = new Set<number>([...x_values, ...x_values.map(flushSubnormalNumber)]);\n  const y_inputs = new Set<number>([...y_values, ...y_values.map(flushSubnormalNumber)]);\n  const z_inputs = new Set<number>([...z_values, ...z_values.map(flushSubnormalNumber)]);\n  const intervals = new Set<F32Interval>();\n  // prettier-ignore\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      z_inputs.forEach(inner_z => {\n        intervals.add(op.impl(inner_x, inner_y, inner_z));\n      });\n    });\n  });\n\n  return F32Interval.span(...intervals);\n}\n\n/** Calculate the acceptance interval for a unary function over an interval\n *\n * If the interval is actually a point, this just decays to\n * roundAndFlushPointToInterval.\n *\n * The provided domain interval may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runPointOp(x: F32Interval, op: PointToIntervalOp): F32Interval {\n  if (x.isPoint()) {\n    return roundAndFlushPointToInterval(x.begin, op);\n  }\n\n  if (op.extrema !== undefined) {\n    x = op.extrema(x);\n  }\n  return F32Interval.span(\n    roundAndFlushPointToInterval(x.begin, op),\n    roundAndFlushPointToInterval(x.end, op)\n  );\n}\n\n/** Calculate the acceptance interval for a binary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\n// Will be used in test implementations\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction runBinaryOp(x: F32Interval, y: F32Interval, op: BinaryToIntervalOp): F32Interval {\n  if (op.extrema !== undefined) {\n    [x, y] = op.extrema(x, y);\n  }\n  const x_values = new Set<number>([x.begin, x.end]);\n  const y_values = new Set<number>([y.begin, y.end]);\n\n  const results = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      results.add(roundAndFlushBinaryToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  return F32Interval.span(...results);\n}\n\n/** Calculate the acceptance interval for a ternary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param z third input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\n// Will be used in test implementations\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction runTernaryOp(\n  x: F32Interval,\n  y: F32Interval,\n  z: F32Interval,\n  op: TernaryToIntervalOp\n): F32Interval {\n  const x_values = new Set<number>([x.begin, x.end]);\n  const y_values = new Set<number>([y.begin, y.end]);\n  const z_values = new Set<number>([z.begin, z.end]);\n  const results = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      z_values.forEach(inner_z => {\n        results.add(roundAndFlushTernaryToInterval(inner_x, inner_y, inner_z, op));\n      });\n    });\n  });\n\n  return F32Interval.span(...results);\n}\n\n/** @returns an interval of the correctly rounded values around the point */\nexport function correctlyRoundedInterval(n: number): F32Interval {\n  return roundAndFlushPointToInterval(n, {\n    impl: (impl_n: number) => {\n      assert(!Number.isNaN(impl_n), `absolute not defined for NaN`);\n      return toInterval(impl_n);\n    },\n  });\n}\n\n/** @returns an interval of the absolute error around the point */\nexport function absoluteErrorInterval(n: number, error_range: number): F32Interval {\n  return roundAndFlushPointToInterval(n, {\n    impl: (impl_n: number) => {\n      assert(!Number.isNaN(n), `absolute not defined for NaN`);\n      if (!isF32Finite(n)) {\n        return toInterval(n);\n      }\n\n      return new F32Interval(impl_n - error_range, impl_n + error_range);\n    },\n  });\n}\n\n/** @returns an interval of N * ULP around the point */\nexport function ulpInterval(n: number, numULP: number): F32Interval {\n  numULP = Math.abs(numULP);\n  return roundAndFlushPointToInterval(n, {\n    impl: (impl_n: number) => {\n      if (!isF32Finite(n)) {\n        return toInterval(n);\n      }\n\n      const ulp = oneULP(impl_n);\n      const begin = impl_n - numULP * ulp;\n      const end = impl_n + numULP * ulp;\n\n      return new F32Interval(\n        Math.min(begin, flushSubnormalNumber(begin)),\n        Math.max(end, flushSubnormalNumber(end))\n      );\n    },\n  });\n}\n\n/** Calculate an acceptance interval for abs(n) */\nexport function absInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return correctlyRoundedInterval(Math.abs(impl_n));\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of atan(x) */\nexport function atanInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return ulpInterval(Math.atan(impl_n), 4096);\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of ceil(x) */\nexport function ceilInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return correctlyRoundedInterval(Math.ceil(impl_n));\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of cos(x) */\nexport function cosInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return kValue.f32.negative.pi.whole <= impl_n && impl_n <= kValue.f32.positive.pi.whole\n        ? absoluteErrorInterval(Math.cos(impl_n), 2 ** -11)\n        : F32Interval.infinite();\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n"],"file":"f32_interval.js"}