{"version":3,"sources":["../../../src/webgpu/util/math.ts"],"names":["assert","kBit","kValue","f32","f32Bits","i32","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumber","val","negative","positive","flushSubnormalScalar","isSubnormalScalar","type","kind","u32_val","Uint32Array","Float32Array","value","valueOf","buffer","isSubnormalNumber","isF32Finite","nextAfter","dir","flush","isNaN","nan","s","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","converted","u32_result","is_positive","next","f32_result","oneULPImpl","target","NaN","nearest_max","nearest_min","b","a","oneULP","undefined","withinULP","ulp","diff","correctlyRounded","test_value","accept_to_zero","accept_no_flush","result","correctlyRoundedImpl","target32","after_target","before_target","correctlyRoundedF32","n_32","other","lerp","t","isFinite","x","linearRange","num_steps","Array","from","keys","map","i","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","neg_sub","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32","num","quantizeToI32","isPowerOfTwo","gcd","bTemp","lcm","hexToF32","hex","hexToF64","h32","l32","u32Arr","f64Arr","Float64Array"],"mappings":";AAAA;AACA,GADA,SAASA,MAAT,QAAuB,2BAAvB,CAEA,SAASC,IAAT,EAAeC,MAAf,QAA6B,gBAA7B;AACA,SAASC,GAAT,EAAcC,OAAd,EAAuBC,GAAvB,QAA0C,iBAA1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,mBAAmB,GAAGC,MAAM,CAACC,gBAAP,GAA0B,CAAtD;;AAEP;AACA;AACA,OAAO,SAASC,KAAT,CAAeC,CAAf,EAA0BC,SAA1B,EAAqD;AAC1DX,EAAAA,MAAM,CAACO,MAAM,CAACK,SAAP,CAAiBF,CAAjB,KAAuBA,CAAC,IAAI,CAA7B,EAAgC,kCAAhC,CAAN;AACAV,EAAAA,MAAM,CAACO,MAAM,CAACK,SAAP,CAAiBD,SAAjB,KAA+BA,SAAS,GAAG,CAA5C,EAA+C,sCAA/C,CAAN;AACA,SAAOE,IAAI,CAACC,IAAL,CAAUJ,CAAC,GAAGC,SAAd,IAA2BA,SAAlC;AACD;;AAED;AACA,OAAO,SAASI,SAAT,CAAmBL,CAAnB,EAA8BC,SAA9B,EAAyD;AAC9DX,EAAAA,MAAM,CAACO,MAAM,CAACK,SAAP,CAAiBF,CAAjB,KAAuBA,CAAC,IAAI,CAA7B,EAAgC,kCAAhC,CAAN;AACAV,EAAAA,MAAM,CAACO,MAAM,CAACK,SAAP,CAAiBD,SAAjB,KAA+BA,SAAS,GAAG,CAA5C,EAA+C,sCAA/C,CAAN;AACA,SAAOE,IAAI,CAACG,KAAL,CAAWN,CAAC,GAAGC,SAAf,IAA4BA,SAAnC;AACD;;AAED;AACA,OAAO,SAASM,KAAT,CAAeP,CAAf,EAA0B,EAAEQ,GAAF,EAAOC,GAAP,EAA1B,EAA8E;AACnFnB,EAAAA,MAAM,CAACmB,GAAG,IAAID,GAAR,CAAN;AACA,SAAOL,IAAI,CAACK,GAAL,CAASL,IAAI,CAACM,GAAL,CAAST,CAAT,EAAYQ,GAAZ,CAAT,EAA2BC,GAA3B,CAAP;AACD;;AAED;AACA,OAAO,SAASC,oBAAT,CAA8BC,GAA9B,EAAmD;AACxD,SAAOA,GAAG,GAAGnB,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBH,GAA1B,IAAiCE,GAAG,GAAGnB,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBL,GAA3D,GAAiE,CAAjE,GAAqEG,GAA5E;AACD;;AAED;AACA,OAAO,SAASG,oBAAT,CAA8BH,GAA9B,EAAmD;AACxD,SAAOI,iBAAiB,CAACJ,GAAD,CAAjB,GAAyBlB,GAAG,CAAC,CAAD,CAA5B,GAAkCkB,GAAzC;AACD;;AAED;AACA;AACA;AACA;AACA,OAAO,SAASI,iBAAT,CAA2BJ,GAA3B,EAAiD;AACtD,MAAIA,GAAG,CAACK,IAAJ,CAASC,IAAT,KAAkB,KAAtB,EAA6B;AAC3B,WAAO,KAAP;AACD;;AAED,MAAIN,GAAG,KAAKlB,GAAG,CAAC,CAAD,CAAf,EAAoB;AAClB,WAAO,KAAP;AACD;;AAED,QAAMyB,OAAO,GAAG,IAAIC,WAAJ,CAAgB,IAAIC,YAAJ,CAAiB,CAACT,GAAG,CAACU,KAAJ,CAAUC,OAAV,EAAD,CAAjB,EAAkDC,MAAlE,EAA0E,CAA1E,CAAhB;AACA,SAAO,CAACL,OAAO,GAAG,UAAX,MAA2B,CAAlC;AACD;;AAED;AACA,OAAO,SAASM,iBAAT,CAA2Bb,GAA3B,EAAiD;AACtD,SAAOI,iBAAiB,CAACtB,GAAG,CAACkB,GAAD,CAAJ,CAAxB;AACD;;AAED;AACA,OAAO,SAASc,WAAT,CAAqBzB,CAArB,EAAgC;AACrC,SAAOA,CAAC,IAAIR,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBJ,GAAzB,IAAgCR,CAAC,IAAIR,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBJ,GAAhE;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiB,SAAT,CAAmBf,GAAnB,EAAgCgB,GAAY,GAAG,IAA/C,EAAqDC,KAArD,EAA6E;AAClF,MAAI/B,MAAM,CAACgC,KAAP,CAAalB,GAAb,CAAJ,EAAuB;AACrB,WAAOjB,OAAO,CAACH,IAAI,CAACE,GAAL,CAASqC,GAAT,CAAajB,QAAb,CAAsBkB,CAAvB,CAAd;AACD;;AAED,MAAIpB,GAAG,KAAKd,MAAM,CAACmC,iBAAnB,EAAsC;AACpC,WAAOtC,OAAO,CAACH,IAAI,CAACE,GAAL,CAASwC,QAAT,CAAkBpB,QAAnB,CAAd;AACD;;AAED,MAAIF,GAAG,KAAKd,MAAM,CAACqC,iBAAnB,EAAsC;AACpC,WAAOxC,OAAO,CAACH,IAAI,CAACE,GAAL,CAASwC,QAAT,CAAkBrB,QAAnB,CAAd;AACD;;AAEDtB,EAAAA,MAAM;AACJqB,EAAAA,GAAG,IAAInB,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBJ,GAA3B,IAAkCE,GAAG,IAAInB,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBJ,GADzD;AAEH,KAAEG,GAAI,iCAFH,CAAN;;;AAKAA,EAAAA,GAAG,GAAGiB,KAAK,GAAGlB,oBAAoB,CAACC,GAAD,CAAvB,GAA+BA,GAA1C;;AAEA;AACA,MAAIA,GAAG,KAAK,CAAZ,EAAe;AACb,QAAIgB,GAAJ,EAAS;AACP,aAAOC,KAAK,GAAGlC,OAAO,CAACH,IAAI,CAACE,GAAL,CAASoB,QAAT,CAAkBL,GAAnB,CAAV,GAAoCd,OAAO,CAACH,IAAI,CAACE,GAAL,CAAS0C,SAAT,CAAmBtB,QAAnB,CAA4BL,GAA7B,CAAvD;AACD,KAFD,MAEO;AACL,aAAOoB,KAAK,GAAGlC,OAAO,CAACH,IAAI,CAACE,GAAL,CAASmB,QAAT,CAAkBH,GAAnB,CAAV,GAAoCf,OAAO,CAACH,IAAI,CAACE,GAAL,CAAS0C,SAAT,CAAmBvB,QAAnB,CAA4BH,GAA7B,CAAvD;AACD;AACF;;AAED,QAAM2B,SAAiB,GAAG,IAAIhB,YAAJ,CAAiB,CAACT,GAAD,CAAjB,EAAwB,CAAxB,CAA1B;AACA,MAAI0B,UAAJ;AACA,MAAI1B,GAAG,KAAKyB,SAAZ,EAAuB;AACrB;AACAC,IAAAA,UAAU,GAAG,IAAIlB,WAAJ,CAAgB,IAAIC,YAAJ,CAAiB,CAACT,GAAD,CAAjB,EAAwBY,MAAxC,EAAgD,CAAhD,CAAb;AACA,UAAMe,WAAW,GAAG,CAACD,UAAU,GAAG,UAAd,MAA8B,CAAlD;AACA,QAAIV,GAAG,KAAKW,WAAZ,EAAyB;AACvBD,MAAAA,UAAU,IAAI,CAAd;AACD,KAFD,MAEO;AACLA,MAAAA,UAAU,IAAI,CAAd;AACD;AACF,GATD,MASO;AACL;AACA,QAAIV,GAAG,KAAKS,SAAS,GAAGzB,GAAxB,EAA6B;AAC3B;AACA0B,MAAAA,UAAU,GAAG,IAAIlB,WAAJ,CAAgB,IAAIC,YAAJ,CAAiB,CAACgB,SAAD,CAAjB,EAA8Bb,MAA9C,EAAsD,CAAtD,CAAb;AACD,KAHD,MAGO;AACL;AACA;AACA,YAAMgB,IAAI,GAAGb,SAAS,CAACU,SAAD,EAAYT,GAAZ,EAAiBC,KAAjB,CAAT,CAAiCP,KAAjC,CAAuCC,OAAvC,EAAb;AACAe,MAAAA,UAAU,GAAG,IAAIlB,WAAJ,CAAgB,IAAIC,YAAJ,CAAiB,CAACmB,IAAD,CAAjB,EAAyBhB,MAAzC,EAAiD,CAAjD,CAAb;AACD;AACF;;AAED;AACA,MAAI,CAACc,UAAU,GAAG,UAAd,MAA8B,UAAlC,EAA8C;AAC5C,QAAIV,GAAJ,EAAS;AACP,aAAOjC,OAAO,CAACH,IAAI,CAACE,GAAL,CAASwC,QAAT,CAAkBpB,QAAnB,CAAd;AACD,KAFD,MAEO;AACL,aAAOnB,OAAO,CAACH,IAAI,CAACE,GAAL,CAASwC,QAAT,CAAkBrB,QAAnB,CAAd;AACD;AACF;;AAED,QAAM4B,UAAU,GAAG9C,OAAO,CAAC2C,UAAD,CAA1B;AACA,SAAOT,KAAK,GAAGd,oBAAoB,CAAC0B,UAAD,CAAvB,GAAsCA,UAAlD;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAT,CAAoBC,MAApB,EAAoCd,KAApC,EAA4D;AAC1D,MAAI/B,MAAM,CAACgC,KAAP,CAAaa,MAAb,CAAJ,EAA0B;AACxB,WAAO7C,MAAM,CAAC8C,GAAd;AACD;;AAEDD,EAAAA,MAAM,GAAGd,KAAK,GAAGlB,oBAAoB,CAACgC,MAAD,CAAvB,GAAkCA,MAAhD;;AAEA;AACA;AACA,MAAIA,MAAM,KAAK7C,MAAM,CAACmC,iBAAlB,IAAuCU,MAAM,IAAIlD,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBJ,GAAzE,EAA8E;AAC5E,WAAOjB,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBJ,GAApB,GAA0BjB,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoB+B,WAArD;AACD,GAFD,MAEO,IAAIF,MAAM,KAAK7C,MAAM,CAACqC,iBAAlB,IAAuCQ,MAAM,IAAIlD,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBJ,GAAzE,EAA8E;AACnF,WAAOhB,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBiC,WAApB,GAAkCrD,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBJ,GAA7D;AACD;;AAED;AACA,QAAMsC,CAAC,GAAGpB,SAAS,CAACgB,MAAD,EAAS,IAAT,EAAed,KAAf,CAAT,CAA+BP,KAA/B,CAAqCC,OAArC,EAAV;AACA,QAAMyB,CAAC,GAAGrB,SAAS,CAACgB,MAAD,EAAS,KAAT,EAAgBd,KAAhB,CAAT,CAAgCP,KAAhC,CAAsCC,OAAtC,EAAV;AACA,QAAMc,SAAiB,GAAG,IAAIhB,YAAJ,CAAiB,CAACsB,MAAD,CAAjB,EAA2B,CAA3B,CAA1B;AACA,MAAIN,SAAS,KAAKM,MAAlB,EAA0B;AACxB;AACA,WAAOvC,IAAI,CAACK,GAAL,CAASkC,MAAM,GAAGK,CAAlB,EAAqBD,CAAC,GAAGJ,MAAzB,CAAP;AACD,GAHD,MAGO;AACL;AACA,WAAOI,CAAC,GAAGC,CAAX;AACD;AACF;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAT,CAAgBN,MAAhB,EAAgCd,KAAhC,EAAyD;AAC9D,MAAIA,KAAK,KAAKqB,SAAd,EAAyB;AACvB,WAAO9C,IAAI,CAACM,GAAL,CAASgC,UAAU,CAACC,MAAD,EAAS,KAAT,CAAnB,EAAoCD,UAAU,CAACC,MAAD,EAAS,IAAT,CAA9C,CAAP;AACD;;AAED,SAAOD,UAAU,CAACC,MAAD,EAASd,KAAT,CAAjB;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsB,SAAT,CAAmBvC,GAAnB,EAAgC+B,MAAhC,EAAgD1C,CAAS,GAAG,CAA5D,EAA+D;AACpE,MAAIH,MAAM,CAACgC,KAAP,CAAalB,GAAb,KAAqBd,MAAM,CAACgC,KAAP,CAAaa,MAAb,CAAzB,EAA+C;AAC7C,WAAO,KAAP;AACD;;AAED,QAAMS,GAAG,GAAGH,MAAM,CAACN,MAAD,CAAlB;AACA,MAAI7C,MAAM,CAACgC,KAAP,CAAasB,GAAb,CAAJ,EAAuB;AACrB,WAAO,KAAP;AACD;;AAED,MAAIxC,GAAG,KAAK+B,MAAZ,EAAoB;AAClB,WAAO,IAAP;AACD;;AAED,QAAMU,IAAI,GAAGzC,GAAG,GAAG+B,MAAN,GAAe/B,GAAG,GAAG+B,MAArB,GAA8BA,MAAM,GAAG/B,GAApD;AACA,SAAOyC,IAAI,IAAIpD,CAAC,GAAGmD,GAAnB;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,gBAAT;AACLC,UADK;AAELZ,MAFK;AAGLa,cAAuB,GAAG,IAHrB;AAILC,eAAwB,GAAG,IAJtB;AAKI;AACTlE,EAAAA,MAAM;AACJiE,EAAAA,cAAc,IAAIC,eADd;AAEH,qEAFG,CAAN;;;AAKA,MAAIC,MAAe,GAAG,KAAtB;AACA,MAAIF,cAAJ,EAAoB;AAClBE,IAAAA,MAAM,GAAGA,MAAM,IAAIC,oBAAoB,CAACJ,UAAD,EAAaZ,MAAb,EAAqB,IAArB,CAAvC;AACD;AACD,MAAIc,eAAJ,EAAqB;AACnBC,IAAAA,MAAM,GAAGA,MAAM,IAAIC,oBAAoB,CAACJ,UAAD,EAAaZ,MAAb,EAAqB,KAArB,CAAvC;AACD;AACD,SAAOe,MAAP;AACD;;AAED;AACA,SAASC,oBAAT,CAA8BJ,UAA9B,EAAkDZ,MAAlD,EAAkEd,KAAlE,EAA2F;AACzFtC,EAAAA,MAAM,CAACgE,UAAU,CAACtC,IAAX,CAAgBC,IAAhB,KAAyB,KAA1B,EAAkC,GAAEqC,UAAW,4BAA/C,CAAN;;AAEA,MAAIzD,MAAM,CAACgC,KAAP,CAAaa,MAAb,CAAJ,EAA0B;AACxB,WAAO7C,MAAM,CAACgC,KAAP,CAAayB,UAAU,CAACjC,KAAX,CAAiBC,OAAjB,EAAb,CAAP;AACD;;AAED,MAAIoB,MAAM,KAAK7C,MAAM,CAACmC,iBAAtB,EAAyC;AACvC,WAAOsB,UAAU,CAACjC,KAAX,KAAqB3B,OAAO,CAACH,IAAI,CAACE,GAAL,CAASwC,QAAT,CAAkBpB,QAAnB,CAAP,CAAoCQ,KAAhE;AACD;;AAED,MAAIqB,MAAM,KAAK7C,MAAM,CAACqC,iBAAtB,EAAyC;AACvC,WAAOoB,UAAU,CAACjC,KAAX,KAAqB3B,OAAO,CAACH,IAAI,CAACE,GAAL,CAASwC,QAAT,CAAkBrB,QAAnB,CAAP,CAAoCS,KAAhE;AACD;;AAEDiC,EAAAA,UAAU,GAAG1B,KAAK,GAAGd,oBAAoB,CAACwC,UAAD,CAAvB,GAAsCA,UAAxD;AACAZ,EAAAA,MAAM,GAAGd,KAAK,GAAGlB,oBAAoB,CAACgC,MAAD,CAAvB,GAAkCA,MAAhD;;AAEA,QAAMiB,QAAQ,GAAG,IAAIvC,YAAJ,CAAiB,CAACsB,MAAD,CAAjB,EAA2B,CAA3B,CAAjB;AACA,QAAMN,SAAiB,GAAGuB,QAA1B;AACA,MAAIjB,MAAM,KAAKN,SAAf,EAA0B;AACxB;AACA,WAAOkB,UAAU,CAACjC,KAAX,KAAqB5B,GAAG,CAACkE,QAAD,CAAH,CAActC,KAA1C;AACD;;AAED,MAAIuC,YAAJ;AACA,MAAIC,aAAJ;;AAEA,MAAIzB,SAAS,GAAGM,MAAhB,EAAwB;AACtB;AACAkB,IAAAA,YAAY,GAAGnE,GAAG,CAACkE,QAAD,CAAlB;AACAE,IAAAA,aAAa,GAAGnC,SAAS,CAACiC,QAAD,EAAW,KAAX,EAAkB/B,KAAlB,CAAzB;AACD,GAJD,MAIO;AACL;AACAgC,IAAAA,YAAY,GAAGlC,SAAS,CAACiC,QAAD,EAAW,IAAX,EAAiB/B,KAAjB,CAAxB;AACAiC,IAAAA,aAAa,GAAGpE,GAAG,CAACkE,QAAD,CAAnB;AACD;;AAED,SAAOL,UAAU,CAACjC,KAAX,KAAqBwC,aAAa,CAACxC,KAAnC,IAA4CiC,UAAU,CAACjC,KAAX,KAAqBuC,YAAY,CAACvC,KAArF;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASyC,mBAAT,CAA6B9D,CAA7B,EAAkD;AACvDV,EAAAA,MAAM,CAAC,CAACO,MAAM,CAACgC,KAAP,CAAa7B,CAAb,CAAF,EAAoB,yCAApB,CAAN;AACA;AACA,MAAIA,CAAC,KAAKH,MAAM,CAACmC,iBAAb,IAAkChC,CAAC,GAAGR,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBJ,GAA9D,EAAmE;AACjE,WAAO,CAACjB,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBJ,GAArB,EAA0BZ,MAAM,CAACmC,iBAAjC,CAAP;AACD;;AAED;AACA,MAAIhC,CAAC,KAAKH,MAAM,CAACqC,iBAAb,IAAkClC,CAAC,GAAGR,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBJ,GAA9D,EAAmE;AACjE,WAAO,CAACX,MAAM,CAACqC,iBAAR,EAA2B1C,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBJ,GAA/C,CAAP;AACD;;AAED,QAAMuD,IAAI,GAAG,IAAI3C,YAAJ,CAAiB,CAACpB,CAAD,CAAjB,EAAsB,CAAtB,CAAb;AACA,QAAMoC,SAAiB,GAAG2B,IAA1B;AACA,MAAI/D,CAAC,KAAKoC,SAAV,EAAqB;AACnB;AACA,WAAO,CAACpC,CAAD,CAAP;AACD;;AAED,MAAIoC,SAAS,GAAGpC,CAAhB,EAAmB;AACjB;AACA,UAAMgE,KAAK,GAAGtC,SAAS,CAACqC,IAAD,EAAO,KAAP,EAAc,KAAd,CAAT,CAA8B1C,KAA5C;AACA,WAAO,CAAC2C,KAAD,EAAQ5B,SAAR,CAAP;AACD,GAJD,MAIO;AACL;AACA,UAAM4B,KAAK,GAAGtC,SAAS,CAACqC,IAAD,EAAO,IAAP,EAAa,KAAb,CAAT,CAA6B1C,KAA3C;AACA,WAAO,CAACe,SAAD,EAAY4B,KAAZ,CAAP;AACD;AACF;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,IAAT,CAAclB,CAAd,EAAyBD,CAAzB,EAAoCoB,CAApC,EAAuD;AAC5D,MAAI,CAACrE,MAAM,CAACsE,QAAP,CAAgBpB,CAAhB,CAAD,IAAuB,CAAClD,MAAM,CAACsE,QAAP,CAAgBrB,CAAhB,CAA5B,EAAgD;AAC9C,WAAOjD,MAAM,CAAC8C,GAAd;AACD;;AAED,MAAKI,CAAC,IAAI,GAAL,IAAYD,CAAC,IAAI,GAAlB,IAA2BC,CAAC,IAAI,GAAL,IAAYD,CAAC,IAAI,GAAhD,EAAsD;AACpD,WAAOoB,CAAC,GAAGpB,CAAJ,GAAQ,CAAC,IAAIoB,CAAL,IAAUnB,CAAzB;AACD;;AAED,MAAImB,CAAC,KAAK,GAAV,EAAe;AACb,WAAOpB,CAAP;AACD;;AAED,QAAMsB,CAAC,GAAGrB,CAAC,GAAGmB,CAAC,IAAIpB,CAAC,GAAGC,CAAR,CAAf;AACA,SAAOmB,CAAC,GAAG,GAAJ,KAAYpB,CAAC,GAAGC,CAAhB,GAAoB5C,IAAI,CAACM,GAAL,CAASqC,CAAT,EAAYsB,CAAZ,CAApB,GAAqCjE,IAAI,CAACK,GAAL,CAASsC,CAAT,EAAYsB,CAAZ,CAA5C;AACD;;AAED;AACA,OAAO,SAASC,WAAT,CAAqBtB,CAArB,EAAgCD,CAAhC,EAA2CwB,SAA3C,EAA6E;AAClF,MAAIA,SAAS,IAAI,CAAjB,EAAoB;AAClB,WAAOC,KAAK,EAAZ;AACD;;AAED;AACA,MAAID,SAAS,KAAK,CAAlB,EAAqB;AACnB,WAAO,CAACvB,CAAD,CAAP;AACD;;AAED,SAAOwB,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACD,SAAD,CAAL,CAAiBG,IAAjB,EAAX,EAAoCC,GAApC,CAAwC,CAAAC,CAAC,KAAIV,IAAI,CAAClB,CAAD,EAAID,CAAJ,EAAO6B,CAAC,IAAIL,SAAS,GAAG,CAAhB,CAAR,CAAjD,CAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,WAAT,CAAqB7B,CAArB,EAAgCD,CAAhC,EAA2CwB,SAA3C,EAA6E;AAClF,QAAMO,CAAC,GAAG,CAAV;AACA,MAAIP,SAAS,IAAI,CAAjB,EAAoB;AAClB,WAAOC,KAAK,EAAZ;AACD;;AAED;AACA,MAAID,SAAS,KAAK,CAAlB,EAAqB;AACnB,WAAO,CAACvB,CAAD,CAAP;AACD;;AAED,SAAOwB,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACD,SAAD,CAAL,CAAiBG,IAAjB,EAAX,EAAoCC,GAApC,CAAwC,CAAAC,CAAC;AAC9CV,EAAAA,IAAI,CAAClB,CAAD,EAAID,CAAJ,EAAO3C,IAAI,CAAC2E,GAAL,CAASb,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAOU,CAAC,IAAIL,SAAS,GAAG,CAAhB,CAAR,CAAb,EAA0CO,CAA1C,CAAP,CADC,CAAP;;AAGD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,YAAT;AACLC,MAKC;;;;;AAAG,EAAEC,OAAO,EAAE,EAAX,EAAeC,QAAQ,EAAE,EAAzB,EANC;AAOU;AACfF,EAAAA,MAAM,CAACG,QAAP,GAAkBH,MAAM,CAACG,QAAP,KAAoBlC,SAApB,GAAgC+B,MAAM,CAACE,QAAvC,GAAkDF,MAAM,CAACG,QAA3E;AACAH,EAAAA,MAAM,CAACI,OAAP,GAAiBJ,MAAM,CAACI,OAAP,KAAmBnC,SAAnB,GAA+B+B,MAAM,CAACC,OAAtC,GAAgDD,MAAM,CAACI,OAAxE;AACA,SAAO;AACL,KAAGR,WAAW,CAACpF,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBH,GAArB,EAA0BjB,MAAM,CAACC,GAAP,CAAWmB,QAAX,CAAoBJ,GAA9C,EAAmDwE,MAAM,CAACG,QAA1D,CADT;AAEL,KAAGd,WAAW;AACZ7E,EAAAA,MAAM,CAACC,GAAP,CAAW0C,SAAX,CAAqBvB,QAArB,CAA8BJ,GADlB;AAEZhB,EAAAA,MAAM,CAACC,GAAP,CAAW0C,SAAX,CAAqBvB,QAArB,CAA8BH,GAFlB;AAGZuE,EAAAA,MAAM,CAACI,OAHK,CAFT;;AAOL,KAPK;AAQL,KAAGf,WAAW;AACZ7E,EAAAA,MAAM,CAACC,GAAP,CAAW0C,SAAX,CAAqBtB,QAArB,CAA8BL,GADlB;AAEZhB,EAAAA,MAAM,CAACC,GAAP,CAAW0C,SAAX,CAAqBtB,QAArB,CAA8BJ,GAFlB;AAGZuE,EAAAA,MAAM,CAACC,OAHK,CART;;AAaL,KAAGL,WAAW,CAACpF,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBL,GAArB,EAA0BhB,MAAM,CAACC,GAAP,CAAWoB,QAAX,CAAoBJ,GAA9C,EAAmDuE,MAAM,CAACE,QAA1D,CAbT,CAAP;;AAeD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,gBAAT;AACLC,CADK;AAELC,CAFK;AAGiB;AACtBjG,EAAAA,MAAM,CAACgG,CAAC,CAACE,MAAF,GAAW,CAAX,IAAgBD,CAAC,CAACC,MAAF,GAAW,CAA3B,IAAgCD,CAAC,CAAC,CAAD,CAAD,CAAKC,MAAL,GAAc,CAA9C,IAAmDF,CAAC,CAAC,CAAD,CAAD,CAAKE,MAAL,KAAgBD,CAAC,CAACC,MAAtE,CAAN;AACA,QAAMC,OAAO,GAAG,IAAIlB,KAAJ,CAAyBe,CAAC,CAACE,MAA3B,CAAhB;AACA,OAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,OAAO,CAACD,MAA5B,EAAoC,EAAEb,CAAtC,EAAyC;AACvCc,IAAAA,OAAO,CAACd,CAAD,CAAP,GAAa,IAAIJ,KAAJ,CAAkBgB,CAAC,CAAC,CAAD,CAAD,CAAKC,MAAvB,EAA+BE,IAA/B,CAAoC,CAApC,CAAb;AACD;;AAED,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAAC,CAACE,MAAtB,EAA8B,EAAEG,CAAhC,EAAmC;AACjC,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAAC,CAAC,CAAD,CAAD,CAAKC,MAAzB,EAAiC,EAAEI,CAAnC,EAAsC;AACpC,WAAK,IAAI5F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuF,CAAC,CAACC,MAAtB,EAA8B,EAAExF,CAAhC,EAAmC;AACjCyF,QAAAA,OAAO,CAACE,CAAD,CAAP,CAAWC,CAAX,KAAiBN,CAAC,CAACK,CAAD,CAAD,CAAK3F,CAAL,IAAUuF,CAAC,CAACvF,CAAD,CAAD,CAAK4F,CAAL,CAA3B;AACD;AACF;AACF;;AAED,SAAOH,OAAP;AACD;;AAED;AACA,OAAO,SAASI,UAAT,CAAoB7F,CAApB,EAA+B8F,IAA/B,EAAqD;AAC1D,QAAMC,KAAK,GAAG,KAAKD,IAAnB;AACA,SAAQ9F,CAAC,IAAI+F,KAAN,IAAgBA,KAAvB;AACD;;AAED;AACA,OAAO,SAASC,aAAT,CAAuBC,GAAvB,EAA4C;AACjD,SAAOxG,GAAG,CAACwG,GAAD,CAAH,CAAS5E,KAAhB;AACD;;AAED;AACA,OAAO,SAAS6E,aAAT,CAAuBD,GAAvB,EAA4C;AACjD,SAAOtG,GAAG,CAACsG,GAAD,CAAH,CAAS5E,KAAhB;AACD;;AAED;AACA,OAAO,SAAS8E,YAAT,CAAsBnG,CAAtB,EAA0C;AAC/C,MAAI,CAACH,MAAM,CAACK,SAAP,CAAiBF,CAAjB,CAAL,EAA0B;AACxB,WAAO,KAAP;AACD;AACD,SAAOA,CAAC,KAAK,CAAN,IAAW,CAACA,CAAC,GAAIA,CAAC,GAAG,CAAV,MAAkB,CAApC;AACD;;AAED;AACA,OAAO,SAASoG,GAAT,CAAarD,CAAb,EAAwBD,CAAxB,EAA2C;AAChDxD,EAAAA,MAAM,CAACO,MAAM,CAACK,SAAP,CAAiB6C,CAAjB,KAAuBA,CAAC,GAAG,CAA5B,CAAN;AACAzD,EAAAA,MAAM,CAACO,MAAM,CAACK,SAAP,CAAiB4C,CAAjB,KAAuBA,CAAC,GAAG,CAA5B,CAAN;;AAEA,SAAOA,CAAC,KAAK,CAAb,EAAgB;AACd,UAAMuD,KAAK,GAAGvD,CAAd;AACAA,IAAAA,CAAC,GAAGC,CAAC,GAAGD,CAAR;AACAC,IAAAA,CAAC,GAAGsD,KAAJ;AACD;;AAED,SAAOtD,CAAP;AACD;;AAED;AACA,OAAO,SAASuD,GAAT,CAAavD,CAAb,EAAwBD,CAAxB,EAA2C;AAChD,SAAQC,CAAC,GAAGD,CAAL,GAAUsD,GAAG,CAACrD,CAAD,EAAID,CAAJ,CAApB;AACD;;AAED;AACA,OAAO,SAASyD,QAAT,CAAkBC,GAAlB,EAAuC;AAC5C,SAAO,IAAIpF,YAAJ,CAAiB,IAAID,WAAJ,CAAgB,CAACqF,GAAD,CAAhB,EAAuBjF,MAAxC,EAAgD,CAAhD,CAAP;AACD;;AAED;AACA,OAAO,SAASkF,QAAT,CAAkBC,GAAlB,EAA+BC,GAA/B,EAAoD;AACzD,QAAMC,MAAM,GAAG,IAAIzF,WAAJ,CAAgB,CAAhB,CAAf;AACAyF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYD,GAAZ;AACAC,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYF,GAAZ;AACA,QAAMG,MAAM,GAAG,IAAIC,YAAJ,CAAiBF,MAAM,CAACrF,MAAxB,CAAf;AACA,SAAOsF,MAAM,CAAC,CAAD,CAAb;AACD","sourcesContent":["import { assert } from '../../common/util/util.js';\n\nimport { kBit, kValue } from './constants.js';\nimport { f32, f32Bits, i32, Scalar } from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumber(val: number): number {\n  return val > kValue.f32.negative.max && val < kValue.f32.positive.min ? 0 : val;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalScalar(val: Scalar): Scalar {\n  return isSubnormalScalar(val) ? f32(0) : val;\n}\n\n/**\n * @returns true if |val| is a subnormal f32 number, otherwise returns false\n * 0 is considered a non-subnormal number by this function.\n */\nexport function isSubnormalScalar(val: Scalar): boolean {\n  if (val.type.kind !== 'f32') {\n    return false;\n  }\n\n  if (val === f32(0)) {\n    return false;\n  }\n\n  const u32_val = new Uint32Array(new Float32Array([val.value.valueOf() as number]).buffer)[0];\n  return (u32_val & 0x7f800000) === 0;\n}\n\n/** Utility to pass TS numbers into |isSubnormalNumber| */\nexport function isSubnormalNumber(val: number): boolean {\n  return isSubnormalScalar(f32(val));\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isF32Finite(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/**\n * @returns the next single precision floating point value after |val|,\n * towards +inf if |dir| is true, otherwise towards -inf.\n * If |flush| is true, all subnormal values will be flushed to 0,\n * before processing.\n * If |flush| is false, the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfter will be the closest subnormal in the correct\n * direction.\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfter(val: number, dir: boolean = true, flush: boolean): Scalar {\n  if (Number.isNaN(val)) {\n    return f32Bits(kBit.f32.nan.positive.s);\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.positive);\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return f32Bits(kBit.f32.infinity.negative);\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of float32`\n  );\n\n  val = flush ? flushSubnormalNumber(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir) {\n      return flush ? f32Bits(kBit.f32.positive.min) : f32Bits(kBit.f32.subnormal.positive.min);\n    } else {\n      return flush ? f32Bits(kBit.f32.negative.max) : f32Bits(kBit.f32.subnormal.negative.max);\n    }\n  }\n\n  const converted: number = new Float32Array([val])[0];\n  let u32_result: number;\n  if (val === converted) {\n    // val is expressible precisely as a float32\n    u32_result = new Uint32Array(new Float32Array([val]).buffer)[0];\n    const is_positive = (u32_result & 0x80000000) === 0;\n    if (dir === is_positive) {\n      u32_result += 1;\n    } else {\n      u32_result -= 1;\n    }\n  } else {\n    // val had to be rounded to be expressed as a float32\n    if (dir === converted > val) {\n      // Rounding was in the direction requested\n      u32_result = new Uint32Array(new Float32Array([converted]).buffer)[0];\n    } else {\n      // Round was opposite of the direction requested, so need nextAfter in the requested direction.\n      // This will not recurse since converted is guaranteed to be a float32 due to the conversion above.\n      const next = nextAfter(converted, dir, flush).value.valueOf() as number;\n      u32_result = new Uint32Array(new Float32Array([next]).buffer)[0];\n    }\n  }\n\n  // Checking for overflow\n  if ((u32_result & 0x7f800000) === 0x7f800000) {\n    if (dir) {\n      return f32Bits(kBit.f32.infinity.positive);\n    } else {\n      return f32Bits(kBit.f32.infinity.negative);\n    }\n  }\n\n  const f32_result = f32Bits(u32_result);\n  return flush ? flushSubnormalScalar(f32_result) : f32_result;\n}\n\n/**\n * @returns ulp(x) for a specific flushing mode\n *\n * This is the main implementation of oneULP, which is normally what should be\n * used. This should only be called directly if a specific flushing mode is\n * required.\n *\n * @param target number to calculate ULP for\n * @param flush should subnormals be flushed to zero\n */\nfunction oneULPImpl(target: number, flush: boolean): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = flush ? flushSubnormalNumber(target) : target;\n\n  // For values at the edge of the range or beyond ulp(x) is defined as the distance between the two nearest\n  // f32 representable numbers to the appropriate edge.\n  if (target === Number.POSITIVE_INFINITY || target >= kValue.f32.positive.max) {\n    return kValue.f32.positive.max - kValue.f32.positive.nearest_max;\n  } else if (target === Number.NEGATIVE_INFINITY || target <= kValue.f32.negative.min) {\n    return kValue.f32.negative.nearest_min - kValue.f32.negative.min;\n  }\n\n  // ulp(x) is min(b-a), where a <= x <= b, a =/= b, a and b are f32 representable\n  const b = nextAfter(target, true, flush).value.valueOf() as number;\n  const a = nextAfter(target, false, flush).value.valueOf() as number;\n  const converted: number = new Float32Array([target])[0];\n  if (converted === target) {\n    // |target| is f32 representable, so either either a or b will be x\n    return Math.min(target - a, b - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return b - a;\n  }\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param flush should subnormals be flushed to zero, if not set both flushed\n *              and non-flush values are considered.\n */\nexport function oneULP(target: number, flush?: boolean): number {\n  if (flush === undefined) {\n    return Math.max(oneULPImpl(target, false), oneULPImpl(target, true));\n  }\n\n  return oneULPImpl(target, flush);\n}\n\n/**\n * @returns if a number is within N * ulp(x) of a target value\n * @param val number to test\n * @param target expected number\n * @param n acceptance range\n * @param flush should subnormals be flushed to zero\n */\nexport function withinULP(val: number, target: number, n: number = 1) {\n  if (Number.isNaN(val) || Number.isNaN(target)) {\n    return false;\n  }\n\n  const ulp = oneULP(target);\n  if (Number.isNaN(ulp)) {\n    return false;\n  }\n\n  if (val === target) {\n    return true;\n  }\n\n  const diff = val > target ? val - target : target - val;\n  return diff <= n * ulp;\n}\n\n// Remove once new FP testing framework is landed\n/**\n * @returns if a test value is correctly rounded to an target value. Only\n * defined for |test_values| being a float32. target values may be any number.\n *\n * Correctly rounded means that if the target value is precisely expressible\n * as a float32, then |test_value| === |target|.\n * Otherwise |test_value| needs to be either the closest expressible number\n * greater or less than |target|.\n *\n * By default internally tests with both subnormals being flushed to 0 and not\n * being flushed, but |accept_to_zero| and |accept_no_flush| can be used to\n * control that behaviour. At least one accept flag must be true.\n */\nexport function correctlyRounded(\n  test_value: Scalar,\n  target: number,\n  accept_to_zero: boolean = true,\n  accept_no_flush: boolean = true\n): boolean {\n  assert(\n    accept_to_zero || accept_no_flush,\n    `At least one of |accept_to_zero| & |accept_no_flush| must be true`\n  );\n\n  let result: boolean = false;\n  if (accept_to_zero) {\n    result = result || correctlyRoundedImpl(test_value, target, true);\n  }\n  if (accept_no_flush) {\n    result = result || correctlyRoundedImpl(test_value, target, false);\n  }\n  return result;\n}\n\n// Remove once new FP testing framework is landed\nfunction correctlyRoundedImpl(test_value: Scalar, target: number, flush: boolean): boolean {\n  assert(test_value.type.kind === 'f32', `${test_value} is expected to be a 'f32'`);\n\n  if (Number.isNaN(target)) {\n    return Number.isNaN(test_value.value.valueOf() as number);\n  }\n\n  if (target === Number.POSITIVE_INFINITY) {\n    return test_value.value === f32Bits(kBit.f32.infinity.positive).value;\n  }\n\n  if (target === Number.NEGATIVE_INFINITY) {\n    return test_value.value === f32Bits(kBit.f32.infinity.negative).value;\n  }\n\n  test_value = flush ? flushSubnormalScalar(test_value) : test_value;\n  target = flush ? flushSubnormalNumber(target) : target;\n\n  const target32 = new Float32Array([target])[0];\n  const converted: number = target32;\n  if (target === converted) {\n    // expected is precisely expressible in float32\n    return test_value.value === f32(target32).value;\n  }\n\n  let after_target: Scalar;\n  let before_target: Scalar;\n\n  if (converted > target) {\n    // target32 is rounded towards +inf, so is after_target\n    after_target = f32(target32);\n    before_target = nextAfter(target32, false, flush);\n  } else {\n    // target32 is rounded towards -inf, so is before_target\n    after_target = nextAfter(target32, true, flush);\n    before_target = f32(target32);\n  }\n\n  return test_value.value === before_target.value || test_value.value === after_target.value;\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if there if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f32 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f32 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f32.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  const n_32 = new Float32Array([n])[0];\n  const converted: number = n_32;\n  if (n === converted) {\n    // n is precisely expressible as a f32, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // x_32 rounded towards +inf, so is after x\n    const other = nextAfter(n_32, false, false).value as number;\n    return [other, converted];\n  } else {\n    // x_32 rounded towards -inf, so is before x\n    const other = nextAfter(n_32, true, false).value as number;\n    return [converted, other];\n  }\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): Array<number> {\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): Array<number> {\n  const c = 2;\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i =>\n    lerp(a, b, Math.pow(lerp(0, 1, i / (num_steps - 1)), c))\n  );\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included. The normal number regions are biased towards zero, and the subnormal regions are linearly spread.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n  return [\n    ...biasedRange(kValue.f32.negative.max, kValue.f32.negative.min, counts.neg_norm),\n    ...linearRange(\n      kValue.f32.subnormal.negative.min,\n      kValue.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0.0,\n    ...linearRange(\n      kValue.f32.subnormal.positive.min,\n      kValue.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...biasedRange(kValue.f32.positive.min, kValue.f32.positive.max, counts.pos_norm),\n  ];\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/** Converts a 32-bit hex values to a 32-bit float value */\nexport function hexToF32(hex: number): number {\n  return new Float32Array(new Uint32Array([hex]).buffer)[0];\n}\n\n/** Converts two 32-bit hex values to a 64-bit float value */\nexport function hexToF64(h32: number, l32: number): number {\n  const u32Arr = new Uint32Array(2);\n  u32Arr[0] = l32;\n  u32Arr[1] = h32;\n  const f64Arr = new Float64Array(u32Arr.buffer);\n  return f64Arr[0];\n}\n"],"file":"math.js"}