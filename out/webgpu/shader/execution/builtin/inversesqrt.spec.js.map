{"version":3,"sources":["../../../../../src/webgpu/shader/execution/builtin/inversesqrt.spec.ts"],"names":["description","makeTestGroup","assert","GPUTest","f32","f32Bits","TypeF32","u32","kBit","run","ulpThreshold","g","lerp","min","max","t","Number","isFinite","NaN","temp","x","Math","unwrapRangeParams","num_steps","type","kind","f32_min","value","f32_max","u32_num_steps","linearRange","Array","from","keys","map","i","biasedRange","c","pow","test","uniqueId","specURL","desc","params","u","combine","undefined","fn","truthFunc","input","expected","sqrt","cases","infinity","positive","concat","cfg","cmpFloats"],"mappings":"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","sourcesContent":["export const description = `\nExecution Tests for the 'inverseSqrt' builtin function\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { f32, f32Bits, Scalar, TypeF32, u32 } from '../../../util/conversion.js';\n\nimport { Case, Config, kBit, run, ulpThreshold } from './builtin.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * Assumes |min| <= |max|, they are internally swapped if needed.\n * If |t| >= 1, then |max| is returned, and if |t| <= 0 |min| is returned.\n * Numerical stability is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nfunction lerp(min: number, max: number, t: number) {\n  if (!Number.isFinite(min) || !Number.isFinite(max) || !Number.isFinite(t)) {\n    return Number.NaN;\n  }\n\n  if (min > max) {\n    const temp = min;\n    min = max;\n    max = temp;\n  }\n\n  if (t <= 0) {\n    return min;\n  }\n\n  if (t >= 1) {\n    return max;\n  }\n\n  if (min === max) {\n    return min;\n  }\n\n  // Don't need the min >= && max <= 0 case, since min < max is already enforced.\n  if (min <= 0 && max >= 0) {\n    return t * max + (1 - t) * min;\n  }\n\n  const x = min + t * (max - min);\n  // t is on (0, 1) here, and min < max, so only need the Math.min() case\n  return Math.min(max, x);\n}\n\n/** Unwrap Scalar params into numbers and check preconditions */\nfunction unwrapRangeParams(min: Scalar, max: Scalar, num_steps: Scalar) {\n  assert(min.type.kind === 'f32', '|min| needs to be a f32');\n  assert(max.type.kind === 'f32', '|max| needs to be a f32');\n  assert(num_steps.type.kind === 'u32', '|num_steps| needs to be a u32');\n\n  const f32_min = min.value as number;\n  const f32_max = max.value as number;\n  const u32_num_steps = num_steps.value as number;\n\n  assert(f32_max > f32_min, '|max| must be greater than |min|');\n  assert(u32_num_steps > 0, '|num_steps| must be greater than 0');\n\n  return { f32_min, f32_max, u32_num_steps };\n}\n\n/** Generate linear range of numbers. */\nfunction linearRange(min: Scalar, max: Scalar, num_steps: Scalar): Array<number> {\n  const { f32_min, f32_max, u32_num_steps } = unwrapRangeParams(min, max, num_steps);\n\n  return Array.from(Array(u32_num_steps).keys()).map(i =>\n    lerp(f32_min, f32_max, i / (u32_num_steps - 1))\n  );\n}\n\n/**\n * Generate non-linear range of numbers, with a bias towards min.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n * */\nfunction biasedRange(min: Scalar, max: Scalar, num_steps: Scalar): Array<number> {\n  const c = 2;\n  const { f32_min, f32_max, u32_num_steps } = unwrapRangeParams(min, max, num_steps);\n\n  return Array.from(Array(u32_num_steps).keys()).map(i =>\n    lerp(f32_min, f32_max, Math.pow(lerp(0, 1, i / (u32_num_steps - 1)), c))\n  );\n}\n\ng.test('float_builtin_functions,inverseSqrt')\n  .uniqueId('84fc180ad82c5618')\n  .specURL('https://www.w3.org/TR/2021/WD-WGSL-20210929/#float-builtin-functions')\n  .desc(\n    `\ninverseSqrt:\nT is f32 or vecN<f32> inverseSqrt(e: T ) -> T Returns the reciprocal of sqrt(e). Component-wise when T is a vector. (GLSLstd450InverseSqrt)\n\nPlease read the following guidelines before contributing:\nhttps://github.com/gpuweb/cts/blob/main/docs/plan_autogen.md\n`\n  )\n  .params(u =>\n    u\n      .combine('storageClass', ['uniform', 'storage_r', 'storage_rw'] as const)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n  )\n  .fn(async t => {\n    // [1]: Need to decide what the ground-truth is.\n    const truthFunc = (x: number): Case => {\n      return { input: f32(x), expected: f32(1 / Math.sqrt(x)) };\n    };\n\n    // Well defined cases\n    let cases: Array<Case> = [\n      { input: f32Bits(kBit.f32.infinity.positive), expected: f32(0) },\n      { input: f32(1), expected: f32(1) },\n    ];\n\n    // 0 < x <= 1 linearly spread\n    cases = cases.concat(\n      linearRange(f32Bits(kBit.f32.positive.min), f32(1), u32(100)).map(x => truthFunc(x))\n    );\n    // 1 <= x < 2^32, biased towards 1\n    cases = cases.concat(biasedRange(f32(1), f32(2 ** 32), u32(1000)).map(x => truthFunc(x)));\n\n    const cfg: Config = t.params;\n    cfg.cmpFloats = ulpThreshold(2);\n    run(t, 'inverseSqrt', [TypeF32], TypeF32, cfg, cases);\n  });\n"],"file":"inversesqrt.spec.js"}